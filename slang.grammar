Grammar: SLang

Terminals Start
WHITESPACE: "([ \n\t])*" IGNORE
LPAREN: "\("
RPAREN: "\)"
COMMA: ","
COLON: ":"
SEMICOLON: ";"
ADD: "+"
SUB: "-"
MUL: "*"
DIV: "/"
NOT: "~"
EQUAL: "="
LT: "<"
ANDOP: "&&"
OROP: "||"
WHAT: "?"
UNIT: "\(\)"
TRUE: "[tT]rue"
FALSE: "[fF]alse"
IF: "if"
THEN: "then"
ELSE: "else"
LET: "let"
IN: "in"
BEGIN: "begin"
END: "end"
BOOL: "bool"
INTTYPE: "int"
UNITTYPE: "unit"
ARROW: "->"
BAR: "|"
INL: "inl"
INR: "inr"
FST: "fst"
SND: "snd"
FUN: "fun"
CASE: "case"
OF: "of"
REF: "ref"
ASSIGN: ":="
BANG: "!"
WHILE: "while"
DO: "do"
INT: "[0-9]([0-9])*" STORE
IDENT: "[a-zA-Z]([a-zA-Z0-9_'])*" STORE
Terminals End

NonTerminals Start
EXPR
EXPR1
SUM
INTERMEDIATE_BINARY_OP
ASSIGNMENT
SIMPLE_EXPR
EXPR_LIST
TYPE
TYPE1
NonTerminals End

Productions Start
EXPR -> EXPR1
      | begin EXPR_LIST end
      | if EXPR then EXPR else EXPR ;
      | while EXPR do EXPR ;
      | fst ( EXPR )
      | snd ( EXPR )
      | inl TYPE ( EXPR )
      | inr TYPE ( EXPR )
      | fun ( IDENT : TYPE ) -> ( EXPR )
      | let IDENT : TYPE = EXPR in ( EXPR )
      | let IDENT ( IDENT : TYPE ) : TYPE = EXPR in ( EXPR )
      | case EXPR of inl ( IDENT : TYPE ) -> EXPR | inr ( IDENT : TYPE ) -> EXPR ;

EXPR1 -> - SIMPLE_EXPR
       | SUM
       | EXPR SIMPLE_EXPR

SUM -> SUM + INTERMEDIATE_BINARY_OP
     | SUM - INTERMEDIATE_BINARY_OP
     | INTERMEDIATE_BINARY_OP

INTERMEDIATE_BINARY_OP -> INTERMEDIATE_BINARY_OP * ASSIGNMENT
	 | INTERMEDIATE_BINARY_OP / ASSIGNMENT
	 | INTERMEDIATE_BINARY_OP < ASSIGNMENT
	 | INTERMEDIATE_BINARY_OP = ASSIGNMENT
	 | INTERMEDIATE_BINARY_OP && ASSIGNMENT
	 | INTERMEDIATE_BINARY_OP || ASSIGNMENT
	 | ASSIGNMENT

ASSIGNMENT -> ASSIGNMENT := ( EXPR )
            | SIMPLE_EXPR

SIMPLE_EXPR -> ()
             | INT
             | ?
             | IDENT
             | TRUE
             | FALSE
             | ( EXPR )
             | ( EXPR , EXPR )
             | ~ ( EXPR )
             | ! ( EXPR )
             | ref ( EXPR )

EXPR_LIST -> EXPR
           | EXPR ; EXPR_LIST

TYPE -> TYPE -> TYPE1
      | TYPE * TYPE1
      | TYPE + TYPE1
      | TYPE ref
      | TYPE1

TYPE1 -> ( TYPE )
       | bool
       | int
       | unit

Productions End

Start Symbol: EXPR

Prefix Start
from slang_ast import AST, Variable, Operator
Prefix End

Class Methods Start
Method Start to_AST(self) -> AST
Class Start EXPR
def to_AST(self) -> AST:
    if len(self.nodes) == 1:
        if isinstance(self.nodes[0], EXPR1):
            return self.nodes[0].to_AST()

    if len(self.nodes) == 3:
        if (
            self.nodes[0] == Terminal("BEGIN")
            and isinstance(self.nodes[1], EXPR_LIST)
            and self.nodes[2] == Terminal("END")
        ):
            # Constructing the Seq happens in EXPR_LIST
            return self.nodes[1].to_AST()

    if len(self.nodes) == 4:
        if (
            self.nodes[0] == Terminal("FST")
            and self.nodes[1] == Terminal("O_PAREN")
            and isinstance(self.nodes[2], EXPR)
            and self.nodes[3] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Fst, [self.nodes[2].to_AST()])

        if (
            self.nodes[0] == Terminal("SND")
            and self.nodes[1] == Terminal("O_PAREN")
            and isinstance(self.nodes[2], EXPR)
            and self.nodes[3] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Snd, [self.nodes[2].to_AST()])

    if len(self.nodes) == 5:
        if (
            self.nodes[0] == Terminal("WHILE")
            and isinstance(self.nodes[1], EXPR)
            and self.nodes[2] == Terminal("DO")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("SEMICOLON")
        ):
            return AST(
                AST.Kind.While, [self.nodes[1].to_AST(), self.nodes[3].to_AST()]
            )

        if (
            self.nodes[0] == Terminal("INL")
            # TODO: Type Check
            and self.nodes[2] == Terminal("O_PAREN")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Inl, [self.nodes[3].to_AST()])

        if (
            self.nodes[0] == Terminal("INR")
            # TODO: Type Check
            and self.nodes[2] == Terminal("O_PAREN")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Inl, [self.nodes[3].to_AST()])

    if len(self.nodes) == 7:
        if (
            self.nodes[0] == Terminal("IF")
            and isinstance(self.nodes[1], EXPR)
            and self.nodes[2] == Terminal("THEN")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("ELSE")
            and isinstance(self.nodes[5], EXPR)
            and self.nodes[6] == Terminal("SEMICOLON")
        ):
            return AST(
                AST.Kind.If,
                [
                    self.nodes[1].to_AST(),
                    self.nodes[3].to_AST(),
                    self.nodes[5].to_AST(),
                ],
            )

    if len(self.nodes) == 10:
        if (
            self.nodes[0] == Terminal("FUN")
            and self.nodes[1] == Terminal("O_PAREN")
            and self.nodes[2] == Terminal("IDENT")
            and isinstance(self.nodes[2], Terminal)
            and self.nodes[2].value is not None
            and self.nodes[3] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[5] == Terminal("C_PAREN")
            and self.nodes[6] == Terminal("ARROW")
            and self.nodes[7] == Terminal("O_PAREN")
            and isinstance(self.nodes[8], EXPR)
            and self.nodes[9] == Terminal("C_PAREN")
        ):
            return AST(
                AST.Kind.Lambda,
                [
                    Variable(self.nodes[2].value),
                    self.nodes[8].to_AST(),
                ],
            )

        if (
            self.nodes[0] == Terminal("LET")
            and self.nodes[1] == Terminal("IDENT")
            and isinstance(self.nodes[1], Terminal)
            and self.nodes[1].value is not None
            and self.nodes[2] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[4] == Terminal("EQUAL")
            and isinstance(self.nodes[5], EXPR)
            and self.nodes[6] == Terminal("IN")
            and self.nodes[7] == Terminal("O_PAREN")
            and isinstance(self.nodes[8], EXPR)
            and self.nodes[9] == Terminal("C_PAREN")
        ):
            # Need to transform the let into a lambda + application
            # As in Lecture 7, slide 11
            return AST(
                AST.Kind.App,
                [
                    AST(
                        AST.Kind.Lambda,
                        [
                            Variable(self.nodes[1].value),
                            self.nodes[8].to_AST(),
                        ],
                    ),
                    self.nodes[5].to_AST(),
                ],
            )

    if len(self.nodes) == 15:
        if (
            self.nodes[0] == Terminal("LET")
            and self.nodes[1] == Terminal("IDENT")
            and isinstance(self.nodes[1], Terminal)
            and self.nodes[1].value is not None
            and self.nodes[2] == Terminal("O_PAREN")
            and self.nodes[3] == Terminal("IDENT")
            and isinstance(self.nodes[3], Terminal)
            and self.nodes[3].value is not None
            and self.nodes[4] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[6] == Terminal("C_PAREN")
            and self.nodes[7] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[9] == Terminal("EQUAL")
            and isinstance(self.nodes[10], EXPR)
            and self.nodes[11] == Terminal("IN")
            and self.nodes[12] == Terminal("O_PAREN")
            and isinstance(self.nodes[13], EXPR)
            and self.nodes[14] == Terminal("C_PAREN")
        ):
            return AST(
                AST.Kind.LetFun,
                [
                    Variable(self.nodes[1].value),
                    Variable(self.nodes[3].value),
                    self.nodes[10].to_AST(),
                    self.nodes[13].to_AST(),
                ],
            )

    if len(self.nodes) == 21:
        if (
            self.nodes[0] == Terminal("CASE")
            and isinstance(self.nodes[1], EXPR)
            and self.nodes[2] == Terminal("OF")
            and self.nodes[3] == Terminal("INL")
            and self.nodes[4] == Terminal("O_PAREN")
            and self.nodes[5] == Terminal("IDENT")
            and isinstance(self.nodes[5], Terminal)
            and self.nodes[5].value is not None
            and self.nodes[6] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[8] == Terminal("C_PAREN")
            and self.nodes[9] == Terminal("ARROW")
            and isinstance(self.nodes[10], EXPR)
            and self.nodes[11] == Terminal("BAR")
            and self.nodes[12] == Terminal("INR")
            and self.nodes[13] == Terminal("O_PAREN")
            and self.nodes[14] == Terminal("IDENT")
            and isinstance(self.nodes[14], Terminal)
            and self.nodes[14].value is not None
            and self.nodes[15] == Terminal("COLON")
            # TODO: Type Check
            and self.nodes[17] == Terminal("C_PAREN")
            and self.nodes[18] == Terminal("ARROW")
            and isinstance(self.nodes[19], EXPR)
            and self.nodes[20] == Terminal("SEMICOLON")
        ):
            return AST(
                AST.Kind.LetFun,
                [
                    self.nodes[1].to_AST(),
                    Variable(self.nodes[5].value),
                    self.nodes[10].to_AST(),
                    Variable(self.nodes[14].value),
                    self.nodes[19].to_AST(),
                ],
            )

    assert False, "Invalid EXPR"
Class End EXPR
Class Start EXPR1
def to_AST(self) -> AST:
    if len(self.nodes) == 1 and isinstance(self.nodes[0], SUM):
        return self.nodes[0].to_AST()
    if len(self.nodes) == 2:
        if self.nodes[0] == Terminal("SUB") and isinstance(
            self.nodes[1], SIMPLE_EXPR
        ):
            return AST(
                AST.Kind.UnaryOp, [Operator.UnaryNegation, self.nodes[1].to_AST()]
            )
        if isinstance(self.nodes[0], EXPR) and isinstance(
            self.nodes[1], SIMPLE_EXPR
        ):
            return AST(
                AST.Kind.App, [self.nodes[0].to_AST(), self.nodes[1].to_AST()]
            )
    assert False, "Invalid EXPR1"
Class End EXPR1
Class Start SUM
def to_AST(self) -> AST:
    if len(self.nodes) == 1 and isinstance(self.nodes[0], INTERMEDIATE_BINARY_OP):
        return self.nodes[0].to_AST()
    if (
        len(self.nodes) == 3
        and isinstance(self.nodes[0], SUM)
        and isinstance(self.nodes[2], INTERMEDIATE_BINARY_OP)
    ):
        if self.nodes[1] == Terminal("SUB"):
            op = Operator.Sub
        elif self.nodes[1] == Terminal("ADD"):
            op = Operator.Add
        else:
            assert False, "Invalid SUM"
        return AST(
            AST.Kind.BinaryOp, [self.nodes[0].to_AST(), op, self.nodes[2].to_AST()]
        )
    assert False, "Invalid SUM"
Class End SUM
Class Start INTERMEDIATE_BINARY_OP
def to_AST(self) -> AST:
    if len(self.nodes) == 1 and isinstance(self.nodes[0], ASSIGNMENT):
        return self.nodes[0].to_AST()
    if (
        len(self.nodes) == 3
        and isinstance(self.nodes[0], INTERMEDIATE_BINARY_OP)
        and isinstance(self.nodes[2], ASSIGNMENT)
    ):
        if self.nodes[1] == Terminal("MUL"):
            op = Operator.Mul
        elif self.nodes[1] == Terminal("DIV"):
            op = Operator.Div
        elif self.nodes[1] == Terminal("LESS_THAN"):
            op = Operator.LessThan
        elif self.nodes[1] == Terminal("EQUAL"):
            op = Operator.Eq
        elif self.nodes[1] == Terminal("ANDOP"):
            op = Operator.And
        elif self.nodes[1] == Terminal("OROP"):
            op = Operator.Or
        else:
            assert False, "Invalid INTERMEDIATE_BINARY_OP"
        return AST(
            AST.Kind.BinaryOp, [self.nodes[0].to_AST(), op, self.nodes[2].to_AST()]
        )
    assert False, "Invalid INTERMEDIATE_BINARY_OP"
Class End INTERMEDIATE_BINARY_OP
Class Start ASSIGNMENT
def to_AST(self) -> AST:
    if len(self.nodes) == 1 and isinstance(self.nodes[0], SIMPLE_EXPR):
        return self.nodes[0].to_AST()
    if len(self.nodes) == 5:
        if (
            isinstance(self.nodes[0], ASSIGNMENT)
            and self.nodes[1] == Terminal("ASSIGN")
            and self.nodes[2] == Terminal("O_PAREN")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("C_PAREN")
        ):
            return AST(
                AST.Kind.Assign, [self.nodes[0].to_AST(), self.nodes[3].to_AST()]
            )
    assert False, "Invalid ASSIGNMENT"
Class End ASSIGNMENT
Class Start SIMPLE_EXPR
def to_AST(self) -> AST:
    if len(self.nodes) == 1:
        if self.nodes[0] == Terminal("UNIT"):
            return AST(AST.Kind.Unit, [])
        if (
            self.nodes[0] == Terminal("INT")
            and isinstance(self.nodes[0], Terminal)
            and self.nodes[0].value is not None
        ):
            return AST(AST.Kind.Int, [int(self.nodes[0].value)])

        if self.nodes[0] == Terminal("WHAT"):
            return AST(AST.Kind.What, [])

        if (
            self.nodes[0] == Terminal("IDENT")
            and isinstance(self.nodes[0], Terminal)
            and self.nodes[0].value is not None
        ):
            return AST(AST.Kind.Var, [Variable(self.nodes[0].value)])

        if self.nodes[0] == Terminal("TRUE"):
            return AST(AST.Kind.Bool, [True])

        if self.nodes[0] == Terminal("FALSE"):
            return AST(AST.Kind.Bool, [False])

    if len(self.nodes) == 3:
        if (
            self.nodes[0] == Terminal("O_PAREN")
            and isinstance(self.nodes[1], EXPR)
            and self.nodes[2] == Terminal("C_PAREN")
        ):
            return self.nodes[1].to_AST()
    if len(self.nodes) == 4:
        if (
            self.nodes[0] == Terminal("NOT")
            and self.nodes[1] == Terminal("O_PAREN")
            and isinstance(self.nodes[2], EXPR)
            and self.nodes[3] == Terminal("C_PAREN")
        ):
            return AST(
                AST.Kind.UnaryOp, [Operator.UnaryNot, self.nodes[2].to_AST()]
            )

        if (
            self.nodes[0] == Terminal("BANG")
            and self.nodes[1] == Terminal("O_PAREN")
            and isinstance(self.nodes[2], EXPR)
            and self.nodes[3] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Deref, [self.nodes[2].to_AST()])

        if (
            self.nodes[0] == Terminal("REF")
            and self.nodes[1] == Terminal("O_PAREN")
            and isinstance(self.nodes[2], EXPR)
            and self.nodes[3] == Terminal("C_PAREN")
        ):
            return AST(AST.Kind.Ref, [self.nodes[2].to_AST()])

    if len(self.nodes) == 5:
        if (
            self.nodes[0] == Terminal("O_PAREN")
            and isinstance(self.nodes[1], EXPR)
            and self.nodes[2] == Terminal("COMMA")
            and isinstance(self.nodes[3], EXPR)
            and self.nodes[4] == Terminal("C_PAREN")
        ):
            return AST(
                AST.Kind.Pair, [self.nodes[1].to_AST(), self.nodes[3].to_AST()]
            )

    assert False, "Invalid SIMPLE_EXPR"
Class End SIMPLE_EXPR
Method End to_AST(self) -> AST
Class Methods End
